use crate::controller::ControlService;

use log::debug;
use prost::bytes::Buf;

use dualoj_judge::{id::gen::ID, proto::Chunk};
use tar::Archive;
use tonic::{Request, Status, Streaming};

pub(crate) struct Received {
    /// unpack directory.
    pub(crate) dir: temp_dir::TempDir,
    /// ID generated by hash of received archive.
    pub(crate) hashed_id: ID,
}

impl ControlService {
    pub async fn receive_archive(
        &self,
        request: Request<Streaming<Chunk>>,
    ) -> Result<Received, Status> {
        let mut stream = request.into_inner();
        let mut data = Vec::new();
        let mut received_size = 0usize;

        while let Some(chunk) = stream.message().await? {
            received_size += chunk.content.len();
            debug!("received: {} Byte", received_size);

            if received_size > self.archive_size_limit {
                return Err(Status::new(
                    tonic::Code::Aborted,
                    format!(
                        "too large archive, max size is {} Byte",
                        self.archive_size_limit
                    ),
                ));
            }

            data.push(chunk.content);
        }
        let raw = data.concat();

        let id = ID::roll_hash(&raw);
        let save_dir = temp_dir::TempDir::new()?;

        debug!("received complete, unpacking");

        Archive::new(raw.reader()).unpack(save_dir.path())?;

        debug!("unpacked to {} complete", save_dir.path().display());

        Ok(Received {
            dir: save_dir,
            hashed_id: id,
        })
    }
}
